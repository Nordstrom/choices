// Code generated by protoc-gen-go.
// source: storage.proto
// DO NOT EDIT!

/*
Package storage is a generated protocol buffer package.

It is generated from these files:
	storage.proto

It has these top-level messages:
	AllRequest
	AllReply
	CreateRequest
	CreateReply
	ReadRequest
	ReadReply
	UpdateRequest
	UpdateReply
	DeleteRequest
	DeleteReply
	Namespace
	Experiment
	Param
	Value
*/
package storage

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Environment structure
type Environment int32

const (
	Environment_Staging    Environment = 0
	Environment_Production Environment = 1
)

var Environment_name = map[int32]string{
	0: "Staging",
	1: "Production",
}
var Environment_value = map[string]int32{
	"Staging":    0,
	"Production": 1,
}

func (x Environment) String() string {
	return proto.EnumName(Environment_name, int32(x))
}
func (Environment) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// AllRequest retuns all the experiments from the given environment.
type AllRequest struct {
	Environment Environment `protobuf:"varint,1,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *AllRequest) Reset()                    { *m = AllRequest{} }
func (m *AllRequest) String() string            { return proto.CompactTextString(m) }
func (*AllRequest) ProtoMessage()               {}
func (*AllRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AllRequest) GetEnvironment() Environment {
	if m != nil {
		return m.Environment
	}
	return Environment_Staging
}

// The response message containing the Namespaces
type AllReply struct {
	Namespaces []*Namespace `protobuf:"bytes,1,rep,name=namespaces" json:"namespaces,omitempty"`
}

func (m *AllReply) Reset()                    { *m = AllReply{} }
func (m *AllReply) String() string            { return proto.CompactTextString(m) }
func (*AllReply) ProtoMessage()               {}
func (*AllReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AllReply) GetNamespaces() []*Namespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

// CreateRequest request message to create a new namespace in an environment.
type CreateRequest struct {
	Namespace   *Namespace  `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	Environment Environment `protobuf:"varint,2,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *CreateRequest) Reset()                    { *m = CreateRequest{} }
func (m *CreateRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()               {}
func (*CreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateRequest) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *CreateRequest) GetEnvironment() Environment {
	if m != nil {
		return m.Environment
	}
	return Environment_Staging
}

// CreateReply response containing the newly created Namespace.
type CreateReply struct {
	Namespace *Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *CreateReply) Reset()                    { *m = CreateReply{} }
func (m *CreateReply) String() string            { return proto.CompactTextString(m) }
func (*CreateReply) ProtoMessage()               {}
func (*CreateReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// ReadRequest request message to get a namespace by name.
type ReadRequest struct {
	Name        string      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Environment Environment `protobuf:"varint,2,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ReadRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReadRequest) GetEnvironment() Environment {
	if m != nil {
		return m.Environment
	}
	return Environment_Staging
}

// ReadReply response containing the namespace requested.
type ReadReply struct {
	Namespace *Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *ReadReply) Reset()                    { *m = ReadReply{} }
func (m *ReadReply) String() string            { return proto.CompactTextString(m) }
func (*ReadReply) ProtoMessage()               {}
func (*ReadReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ReadReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// UpdateRequest request message to update an existing namespace in an
// environment.
type UpdateRequest struct {
	Namespace   *Namespace  `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	Environment Environment `protobuf:"varint,2,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *UpdateRequest) Reset()                    { *m = UpdateRequest{} }
func (m *UpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateRequest) ProtoMessage()               {}
func (*UpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateRequest) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *UpdateRequest) GetEnvironment() Environment {
	if m != nil {
		return m.Environment
	}
	return Environment_Staging
}

// UpdateReply response containing the updated namespace.
type UpdateReply struct {
	Namespace *Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *UpdateReply) Reset()                    { *m = UpdateReply{} }
func (m *UpdateReply) String() string            { return proto.CompactTextString(m) }
func (*UpdateReply) ProtoMessage()               {}
func (*UpdateReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpdateReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// DeleteRequest request message to delete an existing namespace from an
// environment.
type DeleteRequest struct {
	Name        string      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Environment Environment `protobuf:"varint,2,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeleteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteRequest) GetEnvironment() Environment {
	if m != nil {
		return m.Environment
	}
	return Environment_Staging
}

// DeleteReply response containing the deleted namespace.
type DeleteReply struct {
	Namespace *Namespace `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *DeleteReply) Reset()                    { *m = DeleteReply{} }
func (m *DeleteReply) String() string            { return proto.CompactTextString(m) }
func (*DeleteReply) ProtoMessage()               {}
func (*DeleteReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// Namespace structure
type Namespace struct {
	Name        string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Labels      []string      `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty"`
	Experiments []*Experiment `protobuf:"bytes,3,rep,name=experiments" json:"experiments,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Namespace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Namespace) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Namespace) GetExperiments() []*Experiment {
	if m != nil {
		return m.Experiments
	}
	return nil
}

// Experiment structure
type Experiment struct {
	Name     string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Segments []byte   `protobuf:"bytes,2,opt,name=segments,proto3" json:"segments,omitempty"`
	Params   []*Param `protobuf:"bytes,3,rep,name=params" json:"params,omitempty"`
}

func (m *Experiment) Reset()                    { *m = Experiment{} }
func (m *Experiment) String() string            { return proto.CompactTextString(m) }
func (*Experiment) ProtoMessage()               {}
func (*Experiment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Experiment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Experiment) GetSegments() []byte {
	if m != nil {
		return m.Segments
	}
	return nil
}

func (m *Experiment) GetParams() []*Param {
	if m != nil {
		return m.Params
	}
	return nil
}

// Param structure
type Param struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Param) Reset()                    { *m = Param{} }
func (m *Param) String() string            { return proto.CompactTextString(m) }
func (*Param) ProtoMessage()               {}
func (*Param) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Param) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Param) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Value structure
type Value struct {
	Choices []string  `protobuf:"bytes,1,rep,name=choices" json:"choices,omitempty"`
	Weights []float64 `protobuf:"fixed64,2,rep,packed,name=weights" json:"weights,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Value) GetChoices() []string {
	if m != nil {
		return m.Choices
	}
	return nil
}

func (m *Value) GetWeights() []float64 {
	if m != nil {
		return m.Weights
	}
	return nil
}

func init() {
	proto.RegisterType((*AllRequest)(nil), "AllRequest")
	proto.RegisterType((*AllReply)(nil), "AllReply")
	proto.RegisterType((*CreateRequest)(nil), "CreateRequest")
	proto.RegisterType((*CreateReply)(nil), "CreateReply")
	proto.RegisterType((*ReadRequest)(nil), "ReadRequest")
	proto.RegisterType((*ReadReply)(nil), "ReadReply")
	proto.RegisterType((*UpdateRequest)(nil), "UpdateRequest")
	proto.RegisterType((*UpdateReply)(nil), "UpdateReply")
	proto.RegisterType((*DeleteRequest)(nil), "DeleteRequest")
	proto.RegisterType((*DeleteReply)(nil), "DeleteReply")
	proto.RegisterType((*Namespace)(nil), "Namespace")
	proto.RegisterType((*Experiment)(nil), "Experiment")
	proto.RegisterType((*Param)(nil), "Param")
	proto.RegisterType((*Value)(nil), "Value")
	proto.RegisterEnum("Environment", Environment_name, Environment_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ElwinStorage service

type ElwinStorageClient interface {
	// All returns all the namespaces for a given environment.
	All(ctx context.Context, in *AllRequest, opts ...grpc.CallOption) (*AllReply, error)
	// Create creates a namespace in the given environment.
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateReply, error)
	// Read returns the namespace matching the supplied name from the given
	// environment.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadReply, error)
	// Update replaces the namespace in the given environment with the namespace
	// supplied.
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateReply, error)
	// Delete deletes the namespace from the given environment.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteReply, error)
}

type elwinStorageClient struct {
	cc *grpc.ClientConn
}

func NewElwinStorageClient(cc *grpc.ClientConn) ElwinStorageClient {
	return &elwinStorageClient{cc}
}

func (c *elwinStorageClient) All(ctx context.Context, in *AllRequest, opts ...grpc.CallOption) (*AllReply, error) {
	out := new(AllReply)
	err := grpc.Invoke(ctx, "/ElwinStorage/All", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateReply, error) {
	out := new(CreateReply)
	err := grpc.Invoke(ctx, "/ElwinStorage/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadReply, error) {
	out := new(ReadReply)
	err := grpc.Invoke(ctx, "/ElwinStorage/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateReply, error) {
	out := new(UpdateReply)
	err := grpc.Invoke(ctx, "/ElwinStorage/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteReply, error) {
	out := new(DeleteReply)
	err := grpc.Invoke(ctx, "/ElwinStorage/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ElwinStorage service

type ElwinStorageServer interface {
	// All returns all the namespaces for a given environment.
	All(context.Context, *AllRequest) (*AllReply, error)
	// Create creates a namespace in the given environment.
	Create(context.Context, *CreateRequest) (*CreateReply, error)
	// Read returns the namespace matching the supplied name from the given
	// environment.
	Read(context.Context, *ReadRequest) (*ReadReply, error)
	// Update replaces the namespace in the given environment with the namespace
	// supplied.
	Update(context.Context, *UpdateRequest) (*UpdateReply, error)
	// Delete deletes the namespace from the given environment.
	Delete(context.Context, *DeleteRequest) (*DeleteReply, error)
}

func RegisterElwinStorageServer(s *grpc.Server, srv ElwinStorageServer) {
	s.RegisterService(&_ElwinStorage_serviceDesc, srv)
}

func _ElwinStorage_All_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).All(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/All",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).All(ctx, req.(*AllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ElwinStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ElwinStorage",
	HandlerType: (*ElwinStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "All",
			Handler:    _ElwinStorage_All_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _ElwinStorage_Create_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _ElwinStorage_Read_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ElwinStorage_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ElwinStorage_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

func init() { proto.RegisterFile("storage.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 553 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x54, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xc5, 0x49, 0x9b, 0xd6, 0xb3, 0x8e, 0x15, 0x16, 0xa9, 0x04, 0xab, 0x42, 0xd1, 0x9e, 0xa2,
	0x48, 0x6c, 0x44, 0x50, 0xa9, 0x5a, 0xb8, 0x44, 0x90, 0x2b, 0x2a, 0x1b, 0xc1, 0x89, 0xcb, 0x36,
	0x19, 0x5c, 0x4b, 0x1b, 0xdb, 0xd8, 0x4e, 0x0a, 0x57, 0x7e, 0x81, 0xaf, 0xe2, 0xcc, 0x2f, 0xf0,
	0x21, 0x68, 0xd7, 0xd9, 0xd8, 0xa1, 0x91, 0x20, 0x12, 0xe2, 0x96, 0x99, 0x97, 0x79, 0xef, 0x65,
	0x33, 0x6f, 0xa0, 0x9d, 0x17, 0x49, 0x26, 0x43, 0xe4, 0x69, 0x96, 0x14, 0x49, 0x70, 0x1a, 0x26,
	0x49, 0xa8, 0x70, 0x28, 0xd3, 0x68, 0x28, 0xe3, 0x38, 0x29, 0x64, 0x11, 0x25, 0x71, 0x5e, 0xa2,
	0xec, 0x25, 0xc0, 0x58, 0x29, 0x81, 0x9f, 0x96, 0x98, 0x17, 0x94, 0x03, 0xc1, 0x78, 0x15, 0x65,
	0x49, 0xbc, 0xc0, 0xb8, 0xe8, 0x3a, 0x3d, 0xa7, 0xef, 0x8f, 0x3c, 0x3e, 0xa9, 0x7a, 0xa2, 0xfe,
	0x05, 0xf6, 0x1c, 0x8e, 0xcd, 0x74, 0xaa, 0xbe, 0xd0, 0x01, 0x40, 0x2c, 0x17, 0x98, 0xa7, 0x72,
	0x86, 0x79, 0xd7, 0xe9, 0x35, 0xfb, 0x64, 0x04, 0xfc, 0x8d, 0x6d, 0x89, 0x1a, 0xca, 0x22, 0x68,
	0xbf, 0xca, 0x50, 0x16, 0x68, 0x85, 0xfb, 0xe0, 0x6e, 0x60, 0x23, 0xbb, 0x3d, 0x5b, 0x81, 0xbf,
	0x5b, 0x6c, 0xfc, 0xc9, 0xe2, 0x39, 0x10, 0x2b, 0xa5, 0x5d, 0xfe, 0xb5, 0x10, 0x7b, 0x0b, 0x44,
	0xa0, 0x9c, 0x5b, 0x87, 0x14, 0x0e, 0x34, 0x66, 0x66, 0x5c, 0x61, 0x3e, 0xef, 0xed, 0xe5, 0x0c,
	0xdc, 0x92, 0x72, 0x3f, 0x27, 0x11, 0xb4, 0xdf, 0xa5, 0xf3, 0xff, 0xf5, 0x5a, 0x56, 0x6a, 0x3f,
	0x8f, 0x53, 0x68, 0xbf, 0x46, 0x85, 0x95, 0xc7, 0x7f, 0xf1, 0x5e, 0xe7, 0x40, 0x2c, 0xe9, 0x7e,
	0x6e, 0x3e, 0x82, 0xbb, 0xe9, 0xef, 0x74, 0x72, 0x02, 0x2d, 0x25, 0xaf, 0x51, 0xe5, 0xdd, 0x46,
	0xaf, 0xd9, 0x77, 0xc5, 0xba, 0xa2, 0x4f, 0x80, 0xe0, 0xe7, 0x14, 0xb3, 0x48, 0xeb, 0xe7, 0xdd,
	0xa6, 0xd9, 0x62, 0xc2, 0x27, 0x9b, 0x9e, 0xa8, 0xe3, 0xec, 0x03, 0x40, 0x05, 0xed, 0x14, 0x0a,
	0xe0, 0x38, 0xc7, 0xb0, 0x64, 0xd3, 0xbf, 0xd7, 0x13, 0x9b, 0x9a, 0x3e, 0x86, 0x56, 0x2a, 0x33,
	0xb9, 0xb0, 0x3a, 0x2d, 0x7e, 0xa5, 0x4b, 0xb1, 0xee, 0xb2, 0x0b, 0x38, 0x34, 0x8d, 0x9d, 0xc4,
	0xa7, 0x70, 0xb8, 0x92, 0x6a, 0x89, 0x86, 0x55, 0xcf, 0xbe, 0xd7, 0x95, 0x28, 0x9b, 0xec, 0x05,
	0x1c, 0x9a, 0x9a, 0x76, 0xe1, 0x68, 0x76, 0x93, 0x44, 0x36, 0x92, 0xae, 0xb0, 0xa5, 0x46, 0x6e,
	0x31, 0x0a, 0x6f, 0x8a, 0xf2, 0x0d, 0x1c, 0x61, 0xcb, 0xc1, 0x00, 0x48, 0xed, 0x2f, 0xa1, 0x04,
	0x8e, 0xa6, 0x85, 0x0c, 0xa3, 0x38, 0xec, 0xdc, 0xa3, 0x3e, 0xc0, 0x55, 0x96, 0xcc, 0x97, 0x33,
	0x7d, 0x44, 0x3a, 0xce, 0xe8, 0x7b, 0x03, 0xbc, 0x89, 0xba, 0x8d, 0xe2, 0x69, 0x79, 0x74, 0xe8,
	0x19, 0x34, 0xc7, 0x4a, 0x51, 0xc2, 0xab, 0xb3, 0x12, 0xb8, 0xdc, 0x5e, 0x09, 0x76, 0xf2, 0xf5,
	0xc7, 0xcf, 0x6f, 0x8d, 0x0e, 0x23, 0xe6, 0x1e, 0xad, 0x9e, 0x0e, 0xa5, 0x52, 0x97, 0xce, 0x80,
	0x8e, 0xa1, 0x55, 0xc6, 0x94, 0xfa, 0x7c, 0xeb, 0x34, 0x04, 0x1e, 0xaf, 0xe5, 0x97, 0x3d, 0x32,
	0xf3, 0x0f, 0x98, 0x6f, 0xe7, 0x67, 0x06, 0xd4, 0x14, 0x17, 0x70, 0xa0, 0xd3, 0x45, 0x3d, 0x5e,
	0xcb, 0x6d, 0x00, 0x7c, 0x13, 0x39, 0xf6, 0xd0, 0x0c, 0xdf, 0x67, 0x9e, 0x1d, 0xce, 0x50, 0xce,
	0xd7, 0xea, 0xe5, 0xda, 0x53, 0x9f, 0x6f, 0x45, 0x2d, 0xf0, 0x78, 0x2d, 0x0f, 0x77, 0xd5, 0x97,
	0x06, 0x5c, 0x53, 0x94, 0xbb, 0x4a, 0x7d, 0xbe, 0x95, 0x84, 0xc0, 0xe3, 0xb5, 0x25, 0xbe, 0x4b,
	0x31, 0x37, 0xe0, 0xa5, 0x33, 0xb8, 0x6e, 0x99, 0x93, 0xfc, 0xec, 0x57, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x5a, 0xe9, 0x29, 0x4d, 0xc1, 0x05, 0x00, 0x00,
}
