// Code generated by protoc-gen-go.
// source: storage.proto
// DO NOT EDIT!

/*
Package storage is a generated protocol buffer package.

It is generated from these files:
	storage.proto

It has these top-level messages:
	AllRequest
	NamespacesRequest
	CreateExperimentRequest
	DeleteExperimentRequest
	PublishExperimentRequest
	UnpublishExperimentRequest
	NamespacesReply
	Namespace
	Experiment
*/
package storage

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Environment structure
type Environment int32

const (
	Environment_BAD_ENVIRONMENT Environment = 0
	Environment_STAGING         Environment = 1
	Environment_PRODUCTION      Environment = 2
)

var Environment_name = map[int32]string{
	0: "BAD_ENVIRONMENT",
	1: "STAGING",
	2: "PRODUCTION",
}
var Environment_value = map[string]int32{
	"BAD_ENVIRONMENT": 0,
	"STAGING":         1,
	"PRODUCTION":      2,
}

func (x Environment) String() string {
	return proto.EnumName(Environment_name, int32(x))
}
func (Environment) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Experiment_Param_Value_ValueType int32

const (
	Experiment_Param_Value_BAD_VALUE Experiment_Param_Value_ValueType = 0
	Experiment_Param_Value_UNIFORM   Experiment_Param_Value_ValueType = 1
	Experiment_Param_Value_WEIGHTED  Experiment_Param_Value_ValueType = 2
)

var Experiment_Param_Value_ValueType_name = map[int32]string{
	0: "BAD_VALUE",
	1: "UNIFORM",
	2: "WEIGHTED",
}
var Experiment_Param_Value_ValueType_value = map[string]int32{
	"BAD_VALUE": 0,
	"UNIFORM":   1,
	"WEIGHTED":  2,
}

func (x Experiment_Param_Value_ValueType) String() string {
	return proto.EnumName(Experiment_Param_Value_ValueType_name, int32(x))
}
func (Experiment_Param_Value_ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8, 0, 0, 0}
}

type AllRequest struct {
	Environment Environment `protobuf:"varint,1,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *AllRequest) Reset()                    { *m = AllRequest{} }
func (m *AllRequest) String() string            { return proto.CompactTextString(m) }
func (*AllRequest) ProtoMessage()               {}
func (*AllRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The request message containing labels and environment.
type NamespacesRequest struct {
	Label       string      `protobuf:"bytes,1,opt,name=label" json:"label,omitempty"`
	Environment Environment `protobuf:"varint,2,opt,name=environment,enum=Environment" json:"environment,omitempty"`
}

func (m *NamespacesRequest) Reset()                    { *m = NamespacesRequest{} }
func (m *NamespacesRequest) String() string            { return proto.CompactTextString(m) }
func (*NamespacesRequest) ProtoMessage()               {}
func (*NamespacesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// CreateExperimentRequest is the request used for creating experiments. If the
// namespace is not included then a new namespace will be used.
type CreateExperimentRequest struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  string      `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *CreateExperimentRequest) Reset()                    { *m = CreateExperimentRequest{} }
func (m *CreateExperimentRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateExperimentRequest) ProtoMessage()               {}
func (*CreateExperimentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateExperimentRequest) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

// DeleteExperimentRequest is the request used to delete experiments.
type DeleteExperimentRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteExperimentRequest) Reset()                    { *m = DeleteExperimentRequest{} }
func (m *DeleteExperimentRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteExperimentRequest) ProtoMessage()               {}
func (*DeleteExperimentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// PublishExperimentRequest
type PublishExperimentRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *PublishExperimentRequest) Reset()                    { *m = PublishExperimentRequest{} }
func (m *PublishExperimentRequest) String() string            { return proto.CompactTextString(m) }
func (*PublishExperimentRequest) ProtoMessage()               {}
func (*PublishExperimentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// UnpublishExperimentRequest
type UnpublishExperimentRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *UnpublishExperimentRequest) Reset()                    { *m = UnpublishExperimentRequest{} }
func (m *UnpublishExperimentRequest) String() string            { return proto.CompactTextString(m) }
func (*UnpublishExperimentRequest) ProtoMessage()               {}
func (*UnpublishExperimentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// The response message containing the Namespaces
type NamespacesReply struct {
	Namespaces []*Namespace `protobuf:"bytes,1,rep,name=namespaces" json:"namespaces,omitempty"`
}

func (m *NamespacesReply) Reset()                    { *m = NamespacesReply{} }
func (m *NamespacesReply) String() string            { return proto.CompactTextString(m) }
func (*NamespacesReply) ProtoMessage()               {}
func (*NamespacesReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *NamespacesReply) GetNamespaces() []*Namespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

// Namespace structure
type Namespace struct {
	Name        string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Segments    []byte        `protobuf:"bytes,2,opt,name=segments,proto3" json:"segments,omitempty"`
	Experiments []*Experiment `protobuf:"bytes,3,rep,name=experiments" json:"experiments,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Namespace) GetExperiments() []*Experiment {
	if m != nil {
		return m.Experiments
	}
	return nil
}

// Experiment structure
type Experiment struct {
	Name     string              `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Segments []byte              `protobuf:"bytes,2,opt,name=segments,proto3" json:"segments,omitempty"`
	Params   []*Experiment_Param `protobuf:"bytes,3,rep,name=params" json:"params,omitempty"`
}

func (m *Experiment) Reset()                    { *m = Experiment{} }
func (m *Experiment) String() string            { return proto.CompactTextString(m) }
func (*Experiment) ProtoMessage()               {}
func (*Experiment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Experiment) GetParams() []*Experiment_Param {
	if m != nil {
		return m.Params
	}
	return nil
}

type Experiment_Param struct {
	Name  string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value *Experiment_Param_Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Experiment_Param) Reset()                    { *m = Experiment_Param{} }
func (m *Experiment_Param) String() string            { return proto.CompactTextString(m) }
func (*Experiment_Param) ProtoMessage()               {}
func (*Experiment_Param) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *Experiment_Param) GetValue() *Experiment_Param_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type Experiment_Param_Value struct {
	ValueType Experiment_Param_Value_ValueType `protobuf:"varint,1,opt,name=valueType,enum=Experiment_Param_Value_ValueType" json:"valueType,omitempty"`
	Choices   []string                         `protobuf:"bytes,2,rep,name=choices" json:"choices,omitempty"`
	Weights   []float64                        `protobuf:"fixed64,3,rep,packed,name=weights" json:"weights,omitempty"`
}

func (m *Experiment_Param_Value) Reset()                    { *m = Experiment_Param_Value{} }
func (m *Experiment_Param_Value) String() string            { return proto.CompactTextString(m) }
func (*Experiment_Param_Value) ProtoMessage()               {}
func (*Experiment_Param_Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0, 0} }

func init() {
	proto.RegisterType((*AllRequest)(nil), "AllRequest")
	proto.RegisterType((*NamespacesRequest)(nil), "NamespacesRequest")
	proto.RegisterType((*CreateExperimentRequest)(nil), "CreateExperimentRequest")
	proto.RegisterType((*DeleteExperimentRequest)(nil), "DeleteExperimentRequest")
	proto.RegisterType((*PublishExperimentRequest)(nil), "PublishExperimentRequest")
	proto.RegisterType((*UnpublishExperimentRequest)(nil), "UnpublishExperimentRequest")
	proto.RegisterType((*NamespacesReply)(nil), "NamespacesReply")
	proto.RegisterType((*Namespace)(nil), "Namespace")
	proto.RegisterType((*Experiment)(nil), "Experiment")
	proto.RegisterType((*Experiment_Param)(nil), "Experiment.Param")
	proto.RegisterType((*Experiment_Param_Value)(nil), "Experiment.Param.Value")
	proto.RegisterEnum("Environment", Environment_name, Environment_value)
	proto.RegisterEnum("Experiment_Param_Value_ValueType", Experiment_Param_Value_ValueType_name, Experiment_Param_Value_ValueType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for ElwinStorage service

type ElwinStorageClient interface {
	// All returns all the namespaces for a given environment.
	All(ctx context.Context, in *AllRequest, opts ...grpc.CallOption) (*NamespacesReply, error)
	// Creates an experiment in the staging environment and returns the current
	// namespace uses a new namespace unless a namespace is defined in the
	// request.
	CreateExperiment(ctx context.Context, in *CreateExperimentRequest, opts ...grpc.CallOption) (*Namespace, error)
	// DeleteExperiment will delete an experiment if it is not in prod
	// environment. It returns the staging namespace's current state.
	DeleteExperiment(ctx context.Context, in *DeleteExperimentRequest, opts ...grpc.CallOption) (*Namespace, error)
	// PublishExperiment will copy an experiment from staging to prod. This will
	// create a new namespace in prod if it does not currently exist. It returns
	// the prod namespace's current state.
	PublishExperiment(ctx context.Context, in *PublishExperimentRequest, opts ...grpc.CallOption) (*Namespace, error)
	// UnpublishExperiment will remove an experiment from prod. It returns the
	// prod Namespace if it still exists.
	UnpublishExperiment(ctx context.Context, in *UnpublishExperimentRequest, opts ...grpc.CallOption) (*Namespace, error)
}

type elwinStorageClient struct {
	cc *grpc.ClientConn
}

func NewElwinStorageClient(cc *grpc.ClientConn) ElwinStorageClient {
	return &elwinStorageClient{cc}
}

func (c *elwinStorageClient) All(ctx context.Context, in *AllRequest, opts ...grpc.CallOption) (*NamespacesReply, error) {
	out := new(NamespacesReply)
	err := grpc.Invoke(ctx, "/ElwinStorage/All", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) CreateExperiment(ctx context.Context, in *CreateExperimentRequest, opts ...grpc.CallOption) (*Namespace, error) {
	out := new(Namespace)
	err := grpc.Invoke(ctx, "/ElwinStorage/CreateExperiment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) DeleteExperiment(ctx context.Context, in *DeleteExperimentRequest, opts ...grpc.CallOption) (*Namespace, error) {
	out := new(Namespace)
	err := grpc.Invoke(ctx, "/ElwinStorage/DeleteExperiment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) PublishExperiment(ctx context.Context, in *PublishExperimentRequest, opts ...grpc.CallOption) (*Namespace, error) {
	out := new(Namespace)
	err := grpc.Invoke(ctx, "/ElwinStorage/PublishExperiment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) UnpublishExperiment(ctx context.Context, in *UnpublishExperimentRequest, opts ...grpc.CallOption) (*Namespace, error) {
	out := new(Namespace)
	err := grpc.Invoke(ctx, "/ElwinStorage/UnpublishExperiment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ElwinStorage service

type ElwinStorageServer interface {
	// All returns all the namespaces for a given environment.
	All(context.Context, *AllRequest) (*NamespacesReply, error)
	// Creates an experiment in the staging environment and returns the current
	// namespace uses a new namespace unless a namespace is defined in the
	// request.
	CreateExperiment(context.Context, *CreateExperimentRequest) (*Namespace, error)
	// DeleteExperiment will delete an experiment if it is not in prod
	// environment. It returns the staging namespace's current state.
	DeleteExperiment(context.Context, *DeleteExperimentRequest) (*Namespace, error)
	// PublishExperiment will copy an experiment from staging to prod. This will
	// create a new namespace in prod if it does not currently exist. It returns
	// the prod namespace's current state.
	PublishExperiment(context.Context, *PublishExperimentRequest) (*Namespace, error)
	// UnpublishExperiment will remove an experiment from prod. It returns the
	// prod Namespace if it still exists.
	UnpublishExperiment(context.Context, *UnpublishExperimentRequest) (*Namespace, error)
}

func RegisterElwinStorageServer(s *grpc.Server, srv ElwinStorageServer) {
	s.RegisterService(&_ElwinStorage_serviceDesc, srv)
}

func _ElwinStorage_All_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).All(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/All",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).All(ctx, req.(*AllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_CreateExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExperimentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).CreateExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/CreateExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).CreateExperiment(ctx, req.(*CreateExperimentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_DeleteExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExperimentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).DeleteExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/DeleteExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).DeleteExperiment(ctx, req.(*DeleteExperimentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_PublishExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishExperimentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).PublishExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/PublishExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).PublishExperiment(ctx, req.(*PublishExperimentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_UnpublishExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpublishExperimentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).UnpublishExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ElwinStorage/UnpublishExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).UnpublishExperiment(ctx, req.(*UnpublishExperimentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ElwinStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ElwinStorage",
	HandlerType: (*ElwinStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "All",
			Handler:    _ElwinStorage_All_Handler,
		},
		{
			MethodName: "CreateExperiment",
			Handler:    _ElwinStorage_CreateExperiment_Handler,
		},
		{
			MethodName: "DeleteExperiment",
			Handler:    _ElwinStorage_DeleteExperiment_Handler,
		},
		{
			MethodName: "PublishExperiment",
			Handler:    _ElwinStorage_PublishExperiment_Handler,
		},
		{
			MethodName: "UnpublishExperiment",
			Handler:    _ElwinStorage_UnpublishExperiment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("storage.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 555 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0x51, 0x6f, 0xd2, 0x50,
	0x18, 0x5d, 0x8b, 0x6c, 0xeb, 0x29, 0xdb, 0xca, 0x9d, 0x09, 0xb5, 0xfa, 0x80, 0x7d, 0x30, 0x38,
	0xc3, 0x8d, 0xc1, 0xf8, 0x62, 0x66, 0x26, 0x8e, 0x8a, 0x24, 0xae, 0x90, 0x3b, 0xc0, 0xf8, 0x64,
	0xca, 0xbc, 0x81, 0x9a, 0x52, 0x6a, 0x0b, 0x9b, 0x7b, 0xf3, 0x17, 0xf9, 0xe2, 0xbf, 0xf2, 0x57,
	0x98, 0xb6, 0xd0, 0x76, 0x1d, 0xc4, 0xed, 0x85, 0xf0, 0x7d, 0xe7, 0x9c, 0xef, 0x5c, 0xbe, 0x7b,
	0x0f, 0xd8, 0x0b, 0xe6, 0x33, 0xdf, 0x1a, 0x73, 0xea, 0xf9, 0xb3, 0xf9, 0x4c, 0x3f, 0x06, 0x9a,
	0x8e, 0xc3, 0xf8, 0x8f, 0x05, 0x0f, 0xe6, 0x84, 0x42, 0xe6, 0xee, 0xa5, 0xed, 0xcf, 0xdc, 0x29,
	0x77, 0xe7, 0xaa, 0x50, 0x15, 0x6a, 0xfb, 0x8d, 0x12, 0x35, 0xd2, 0x1e, 0xcb, 0x12, 0xf4, 0x2f,
	0x28, 0x9b, 0xd6, 0x94, 0x07, 0x9e, 0x75, 0xc1, 0x83, 0xd5, 0x90, 0x87, 0x28, 0x3a, 0xd6, 0x88,
	0x3b, 0x91, 0x5c, 0x62, 0x71, 0x91, 0x1f, 0x2d, 0xfe, 0x6f, 0xf4, 0x37, 0x54, 0x4e, 0x7d, 0x6e,
	0xcd, 0xb9, 0xf1, 0xd3, 0xe3, 0xbe, 0x1d, 0x11, 0x96, 0x06, 0x2f, 0x00, 0x9e, 0x34, 0x23, 0x17,
	0xb9, 0x21, 0xd3, 0x0c, 0x2f, 0x03, 0x93, 0x27, 0x90, 0xdc, 0xd5, 0x11, 0x23, 0x57, 0x89, 0xa5,
	0x0d, 0xbd, 0x8e, 0x4a, 0x8b, 0x3b, 0x7c, 0x9d, 0x0b, 0xc1, 0x83, 0x90, 0xb7, 0xfc, 0x15, 0xd1,
	0x77, 0x9d, 0x42, 0xed, 0x2d, 0x46, 0x8e, 0x1d, 0x4c, 0xee, 0xc6, 0x7f, 0x09, 0x6d, 0xe0, 0x7a,
	0xf7, 0x51, 0xbc, 0xc5, 0x41, 0x76, 0xa3, 0x9e, 0x73, 0x4d, 0x8e, 0x80, 0xe4, 0xc0, 0x81, 0x2a,
	0x54, 0x0b, 0x35, 0xb9, 0x01, 0x9a, 0xb0, 0x58, 0x06, 0xd5, 0xbf, 0x43, 0x4a, 0x80, 0x75, 0xf3,
	0x89, 0x86, 0xdd, 0x80, 0x8f, 0xc3, 0x53, 0x04, 0xd1, 0x36, 0x4a, 0x2c, 0xa9, 0x49, 0x1d, 0x72,
	0xba, 0xb8, 0x40, 0x2d, 0x44, 0x4e, 0x37, 0x16, 0x9b, 0xc5, 0xf5, 0xbf, 0x22, 0x90, 0x62, 0xf7,
	0x76, 0x7b, 0x8e, 0x6d, 0xcf, 0xf2, 0xad, 0xe9, 0xca, 0xa8, 0x9c, 0x31, 0xa2, 0xbd, 0x10, 0x61,
	0x4b, 0x82, 0xf6, 0x4b, 0x44, 0x31, 0xea, 0xac, 0x35, 0xa9, 0xa3, 0x78, 0x69, 0x39, 0x8b, 0xf8,
	0x76, 0xe5, 0x46, 0xe5, 0xd6, 0x1c, 0x3a, 0x0c, 0x61, 0x16, 0xb3, 0xb4, 0x3f, 0x02, 0x8a, 0x51,
	0x83, 0x9c, 0x40, 0x8a, 0x5a, 0xfd, 0x6b, 0x8f, 0x2f, 0xdf, 0xfa, 0xd3, 0x0d, 0xe2, 0xf8, 0x33,
	0x24, 0xb2, 0x54, 0x43, 0x54, 0xec, 0x5c, 0x4c, 0x66, 0x76, 0x78, 0x2d, 0x62, 0xb5, 0x50, 0x93,
	0xd8, 0xaa, 0x0c, 0x91, 0x2b, 0x6e, 0x8f, 0x27, 0xcb, 0x35, 0x0a, 0x6c, 0x55, 0xea, 0xaf, 0x21,
	0x25, 0xb3, 0xc8, 0x1e, 0xa4, 0xf7, 0xcd, 0xd6, 0xd7, 0x61, 0xf3, 0xd3, 0xc0, 0x50, 0xb6, 0x88,
	0x8c, 0x9d, 0x81, 0xd9, 0xf9, 0xd0, 0x65, 0x67, 0x8a, 0x40, 0x4a, 0xd8, 0xfd, 0x6c, 0x74, 0xda,
	0x1f, 0xfb, 0x46, 0x4b, 0x11, 0x8f, 0x4e, 0x20, 0x67, 0xa2, 0x42, 0x0e, 0x71, 0x10, 0x0a, 0x0d,
	0x73, 0xd8, 0x61, 0x5d, 0xf3, 0xcc, 0x30, 0xfb, 0xb1, 0xfc, 0xbc, 0xdf, 0x6c, 0x77, 0xcc, 0xb6,
	0x22, 0x90, 0x7d, 0xa0, 0xc7, 0xba, 0xad, 0xc1, 0x69, 0xbf, 0xd3, 0x35, 0x15, 0xb1, 0xf1, 0x5b,
	0x44, 0xc9, 0x70, 0xae, 0x6c, 0xf7, 0x3c, 0xce, 0x3f, 0x79, 0x86, 0x42, 0xd3, 0x71, 0x88, 0x4c,
	0xd3, 0xfc, 0x6b, 0x0a, 0xcd, 0x3d, 0x3e, 0x7d, 0x8b, 0xbc, 0x81, 0x92, 0x0f, 0x22, 0x51, 0xe9,
	0x86, 0x6c, 0x6a, 0x99, 0x87, 0x19, 0x6b, 0xf3, 0xf1, 0x22, 0x2a, 0xdd, 0x90, 0xb8, 0x9c, 0xf6,
	0x18, 0xe5, 0x5b, 0x59, 0x23, 0x8f, 0xe8, 0xa6, 0xfc, 0xe5, 0xd4, 0xef, 0x70, 0xb8, 0x26, 0x79,
	0xe4, 0x31, 0xdd, 0x9c, 0xc7, 0x9b, 0x13, 0x46, 0xdb, 0xd1, 0x1f, 0xe4, 0xab, 0x7f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x88, 0x94, 0x30, 0xc8, 0x31, 0x05, 0x00, 0x00,
}
